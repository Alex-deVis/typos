#[test]
fn codegen() {
    let mut content = vec![];
    const DICT: &[u8] = include_bytes!("../assets/words.csv");
    generate(&mut content, "WORD", DICT);

    let content = String::from_utf8(content).unwrap();
    let content = codegenrs::rustfmt(&content, None).unwrap();
    snapbox::assert_eq(snapbox::file!["../src/word_codegen.rs"], content);
}

fn generate<W: std::io::Write>(file: &mut W, prefix: &str, dict: &[u8]) {
    writeln!(
        file,
        "// This file is @generated by {}",
        file!().replace('\\', "/")
    )
    .unwrap();
    writeln!(file, "#![allow(clippy::unreadable_literal)]",).unwrap();
    writeln!(file).unwrap();

    let records: Vec<_> = csv::ReaderBuilder::new()
        .has_headers(false)
        .flexible(true)
        .from_reader(dict)
        .records()
        .map(|r| r.unwrap())
        .collect();
    dictgen::generate_trie(
        file,
        prefix,
        "&'static [&'static str]",
        records.iter().map(|record| {
            let mut record_fields = record.iter();
            let key = record_fields.next().unwrap();
            let value = format!(
                "&[{}]",
                itertools::join(record_fields.map(|field| format!(r#""{}""#, field)), ", ")
            );
            (key, value)
        }),
        64,
    )
    .unwrap();
}
